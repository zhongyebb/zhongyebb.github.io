<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>毕设-基于生成式AI的语义通信系统笔记</title>
    <link href="/2025/01/21/%E6%AF%95%E8%AE%BE-%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%BC%8FAI%E7%9A%84%E8%AF%AD%E4%B9%89%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/21/%E6%AF%95%E8%AE%BE-%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%BC%8FAI%E7%9A%84%E8%AF%AD%E4%B9%89%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开题报告</title>
    <link href="/2025/01/03/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/2025/01/03/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="一、国内外关于本选题的研究现状、水平和发展趋势，选题研究的目的和意义等"><a href="#一、国内外关于本选题的研究现状、水平和发展趋势，选题研究的目的和意义等" class="headerlink" title="一、国内外关于本选题的研究现状、水平和发展趋势，选题研究的目的和意义等"></a>一、国内外关于本选题的研究现状、水平和发展趋势，选题研究的目的和意义等</h2><h3 id="1选题背景"><a href="#1选题背景" class="headerlink" title="1选题背景"></a>1选题背景</h3><p>  传统的通信系统以比特为单位进行数据传输，通常通过符号编码将信源映射为比特码流，并通过增加冗余来提升传输的准确性，从而还原原始数据。这种方法在信道质量良好的情况下效果较好，但当信道条件变差，尤其是在高压缩率或低带宽的情况下，传统系统的性能往往无法满足要求。而在图像和视频等多媒体数据传输中，传统的压缩算法如JPEG和JPEG2000容易出现“cliff effect”（悬崖效应），即在压缩率过高时，图像质量会急剧下降。这是因为信道编码和信源编码的速率是针对特定信道质量共同选择的，当信道质量差于预设条件时，差错率会迅速增加，导致重建质量显著下降。<br>  为了解决上述问题，近年来，语义通信（Semantic Communication）作为一种新兴的通信方法得到了广泛关注。与传统通信不同，语义通信的核心在于通过理解信息的“语义”而非单纯传输比特流来提高通信效率。语义通信系统的基本思路是传递信息的意义，而不是传递位级的冗余数据，这对于处理复杂的数据如图像、视频和传感器数据具有重要意义。</p><h3 id="2研究现状"><a href="#2研究现状" class="headerlink" title="2研究现状"></a>2研究现状</h3><p>  在语义通信的研究中，联合源信道编码（JSCC）是一种关键的技术。JSCC通过将信源编码和信道编码联合设计，以适应信道的变化，从而提高通信系统的整体性能。不同于传统的分开设计信源和信道编码的方法，JSCC能够动态调整编码策略，以应对不同信道条件下的数据传输需求，提升系统的鲁棒性和传输效率。近年来，深度学习与JSCC的结合（DeepJSCC）成为语义通信研究中的一个重要方向。DeepJSCC利用深度神经网络对信源和信道进行联合建模，在保证图像质量的同时显著提高传输效率，并杜绝了cliff effect的出现。<br>  随着生成式人工智能（Generative AI）技术的迅速发展，基于生成模型的语义通信方案也得到了研究者们的关注。生成对抗网络（GAN）和变分自编码器（VAE）等生成模型被应用于图像和视频的压缩与重建，能够在不失真或低失真的情况下减少数据的冗余量。较新的一个研究是在DeepJSCC的基础上，引入了生成式AI技术，通过在解码端利用预训练的Diffusion模型来生成高质量的图像。Diffusion模型利用条件去噪过程生成更加真实和细节丰富的图像，这一方法有效提升了图像的恢复质量，突破了传统压缩算法的瓶颈。<br>  当前的研究主要聚焦于如何利用深度学习和生成AI提升通信系统的性能，尤其是在低带宽和低延迟场景下的应用。在图像压缩和恢复的过程中，传统压缩算法在压缩率较高时会导致图像质量严重下降，而基于生成AI的语义通信系统能够通过智能压缩和重建技术解决这一问题，显著提高图像的质量和传输效率。尽管如此，如何将生成AI与JSCC深度结合、在多种应用场景中实现高效的数据传输仍然是该领域面临的重要挑战。</p><h3 id="3研究目的"><a href="#3研究目的" class="headerlink" title="3研究目的"></a>3研究目的</h3><p>  本研究旨在探索基于生成AI的语义通信系统，解决传统通信系统传输效率低下的问题。正如前文所述，传统通信系统的性能容易受压缩率和带宽的影响，且传统的图像压缩算法如JPEG和JPEG2000容易出现“cliff effect”。而基于生成AI的语义通信系统，通过引入深度学习和生成模型，提供了一种新的思路来解决这一问题，实现数据的高效压缩与传输优化。<br>  通过结合DeepJSCC和生成AI技术，尤其是在解码端利用预训练的Diffusion模型进行图像的条件扩散去噪处理，能提升图像传输过程中的质量和效率。在信道质量较差的情况下，生成式AI能够帮助系统生成高质量、细节丰富的重建图像，克服传统压缩算法的局限性，从而提高系统在低延迟和高带宽需求场景中的性能。此外，本研究将进一步探讨如何在实际通信系统中，基于生成式AI的优势实现自适应的编码与解码策略，以提高系统在不同信道条件下的鲁棒性。</p><h3 id="4选题意义"><a href="#4选题意义" class="headerlink" title="4选题意义"></a>4选题意义</h3><p>  本研究具有重要的理论和应用价值。从理论上讲，结合生成式AI与语义通信为该领域提供了新的思路，推动了语义通信在高效数据传输、智能优化等方面的研究进展。从应用上看，基于生成式AI的语义通信系统能够大幅提升数据传输的效率和图像质量，具有广泛的应用前景，特别是在5G/6G、物联网、自动驾驶、虚拟现实（VR）等领域，能够满足这些领域对低延迟、高带宽、高质量通信的需求。因此，本研究不仅具有学术意义，还具有广泛的实际应用价值，将为未来智能通信系统的设计与实现提供新的技术路径和解决方案。</p><h2 id="二、选题研究的计划进度及可行性论述等"><a href="#二、选题研究的计划进度及可行性论述等" class="headerlink" title="二、选题研究的计划进度及可行性论述等"></a>二、选题研究的计划进度及可行性论述等</h2><h3 id="1计划进度"><a href="#1计划进度" class="headerlink" title="1计划进度"></a>1计划进度</h3><ol><li>文献调研与理论框架构建（2024年12月至2025年2月）<br>  这一阶段的重点是深入理解语义通信、联合源信道编码（JSCC）、深度联合源信道编码（DeepJSCC）以及生成AI技术的相关理论与最新进展。通过调研国内外相关文献，明确本研究的创新点和技术路线，构建研究的理论框架，为后续实验与模型设计奠定基础。</li><li>生成AI模型的选型与优化（2025年2月至2025年3月）<br>  在该阶段，将针对生成式AI技术中的生成对抗网络（GAN）、变分自编码器（VAE）和条件扩散去噪模型（Diffusion Models）等进行初步的选型与实验，比较其在图像压缩与恢复中的效果。通过训练不同的生成模型，优化其生成效果与传输效率，并评估其在不同信道条件下的鲁棒性。</li><li>语义通信系统设计与实现（2025年3月至2025年4月）<br>  在这一阶段，将结合DeepJSCC技术与生成式AI模型，设计并实现一个集成的语义通信系统。该系统将重点关注信号的高效传输、低延迟、高质量的图像恢复以及在不稳定信道条件下的适应性。该阶段的目标是开发一个原型系统，并进行测试与优化。</li><li>论文撰写与总结（2025年4月）<br>  在研究的最后阶段，将对研究结果进行总结和整理，撰写论文。论文内容将包括系统设计、模型选择与优化、实验结果分析等方面，并对研究中的不足之处提出改进意见与后续研究方向。</li></ol><h3 id="2可行性论述"><a href="#2可行性论述" class="headerlink" title="2可行性论述"></a>2可行性论述</h3><ol><li>技术可行性<br>  随着深度学习技术和生成式AI的快速发展，相关的工具和模型库（如TensorFlow、PyTorch等）已经相对成熟，可以为本研究提供可靠的技术支持。此外，JSCC和DeepJSCC等技术的研究已取得显著进展，并在图像压缩与恢复领域取得了良好的效果。因此，在已有研究成果的基础上，结合生成AI技术设计高效的语义通信系统是完全可行的。</li><li>数据可用性<br>  本研究涉及图像和视频数据的压缩与恢复，现有的公开数据集（如ImageNet、COCO、UCID等）可以为系统的训练与验证提供丰富的样本。同时，实验中使用的通信模型和信道环境也可以通过仿真工具（如MATLAB）进行模拟，从而确保数据的多样性和实验结果的可靠性。</li><li>实验可行性<br>  本研究的目标是在多种信道条件下评估语义通信系统的性能。通过借助现有的仿真平台和实际硬件设备，可以模拟和测试不同的信道环境，并进行性能比较。例如，系统可以在模拟的低带宽、高噪声环境中进行测试，评估生成式AI在此类场景下的效果。此外，结合深度学习框架，可以在相对较短的时间内完成模型训练与调优，具备较高的实验可操作性。</li></ol><p>  综上所述，本研究在技术、数据、实验等方面具备良好的可行性。通过合理的阶段规划与技术路线，研究能够顺利完成并取得预期的研究成果。</p><h2 id="三、毕业论文（设计）撰写提纲"><a href="#三、毕业论文（设计）撰写提纲" class="headerlink" title="三、毕业论文（设计）撰写提纲"></a>三、毕业论文（设计）撰写提纲</h2><h3 id="0引言"><a href="#0引言" class="headerlink" title="0引言"></a>0引言</h3><ol><li>研究背景<br>  概述传统通信系统的局限性、语义通信的出现及其优势，说明深度学习与生成式AI在通信中的应用前景。</li><li>研究目的与意义<br>  解决传统图像压缩与传输方法中的瓶颈问题，提高低带宽、高延迟环境下的图像传输效率与质量。</li><li>国内外研究现状<br>  国内外在语义通信、JSCC、DeepJSCC、生成AI在通信中的研究进展</li><li>论文结构安排</li></ol><h3 id="1系统设计与模型选择"><a href="#1系统设计与模型选择" class="headerlink" title="1系统设计与模型选择"></a>1系统设计与模型选择</h3><ol><li>系统总体框架<br>  概述从信源编码到信道编码的系统架构，以及DeepJSCC与生成式AI结合的关键技术模块。</li><li>生成式AI模型的选择<br>  比较GAN、VAE与Diffusion等模型，分析优势并得出最终选择。</li><li>DeepJSCC与生成式AI的结合<br>  生成式AI模型在DeepJSCC框架中的应用，以及系统如何联合优化信源编码与信道编码。</li><li>模型架构设计<br>  分别叙述模型架构、算法流程、数据预处理与训练策略。</li></ol><h3 id="2实验与性能评估"><a href="#2实验与性能评估" class="headerlink" title="2实验与性能评估"></a>2实验与性能评估</h3><ol><li>实验设置与环境<br>  低带宽、高噪声与不同信道条件下的测试。</li><li>性能评估指标<ul><li>图像质量：PSNR、SSIM等指标</li><li>传输效率：带宽占用、传输延迟</li><li>系统鲁棒性：错误率与容错能力</li></ul></li><li>实验结果与分析<ul><li>对比分析各项指标下的性能表现</li><li>对比分析生成式AI与传统方法的性能表现</li></ul></li></ol><h3 id="3总结与展望"><a href="#3总结与展望" class="headerlink" title="3总结与展望"></a>3总结与展望</h3><ol><li>研究总结<br>  主要研究成果与贡献，以及基于生成式AI的语义通信系统的优势与创新。</li><li>存在的问题与不足<br>  系统性能的进一步提升空间，以及部分技术实现中的挑战与限制。</li><li>未来研究方向<br>  深化生成式AI与DeepJSCC的结合，并从图像数据传输拓展到多模态数据传输。</li></ol><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><blockquote><p>[1]BOURTSOULATZE E, BURTH KURKA D, GUNDUZ D. Deep Joint Source-Channel Coding for Wireless Image Transmission[J/OL]. IEEE Transactions on Cognitive Communications and Networking, 2019, 5(3): 567-579. DOI:10.1109/TCCN.2019.2919300.<br>[2]JIANG F, PENG Y, DONG L, 等. Large AI Model-Based Semantic Communications[A/OL]. arXiv, 2024[2024-12-17]. <a href="http://arxiv.org/abs/2307.03492">http://arxiv.org/abs/2307.03492</a>. DOI:10.48550/arXiv.2307.03492.<br>[3]PENG B, WANG J, ZHANG Y, 等. ControlNeXt: Powerful and Efficient Control for Image and Video Generation[A/OL]. arXiv, 2024[2024-12-26]. <a href="http://arxiv.org/abs/2408.06070">http://arxiv.org/abs/2408.06070</a>. DOI:10.48550/arXiv.2408.06070.<br>[4]XIE H, QIN Z, LI G Y, 等. Deep Learning Enabled Semantic Communication Systems[J/OL]. IEEE Transactions on Signal Processing, 2021, 69: 2663-2675. DOI:10.1109/TSP.2021.3071210.<br>[5]YANG K, WANG S, DAI J, 等. WITT: A Wireless Image Transmission Transformer for Semantic Communications[C/OL]//ICASSP 2023 - 2023 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP). Rhodes Island, Greece: IEEE, 2023: 1-5[2024-12-17]. <a href="https://ieeexplore.ieee.org/document/10094735/">https://ieeexplore.ieee.org/document/10094735/</a>. DOI:10.1109/ICASSP49357.2023.10094735.<br>[6]YANG M, LIU B, WANG B, 等. Diffusion-Aided Joint Source Channel Coding For High Realism Wireless Image Transmission[A/OL]. arXiv, 2024[2024-12-26]. <a href="http://arxiv.org/abs/2404.17736">http://arxiv.org/abs/2404.17736</a>. DOI:10.48550/arXiv.2404.17736.<br>[7]YANG W, DU H, LIEW Z Q, 等. Semantic Communications for Future Internet: Fundamentals, Applications, and Challenges[J/OL]. IEEE Communications Surveys &amp; Tutorials, 2023, 25(1): 213-250. DOI:10.1109/COMST.2022.3223224.<br>[8]秦志金,赵菼菼,李凡,等.多模态语义通信研究综述[J].通信学报,2023,44(05):28-41.<br>[9]郭畅,何占豪,杨君刚,等.图像语义通信技术综述与展望[J/OL].电讯技术,1-10[2025-01-03].<a href="https://doi.org/10.20079/j.issn.1001-893x.240416001">https://doi.org/10.20079/j.issn.1001-893x.240416001</a>.<br>[10]张可馨,李立欣,林文晟,等.AIGC赋能的图像语义通信系统[J].移动通信,2024,48(10):70-77.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成式AI相关</title>
    <link href="/2024/12/14/%E7%94%9F%E6%88%90%E5%BC%8FAI%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/12/14/%E7%94%9F%E6%88%90%E5%BC%8FAI%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<ul><li>pre-train预训练：利用网上爬取的大量资料使模型认识世界</li><li>instruction Fine-tuning微调：利用人类标注过的资料进行训练，使之能理解并正确回答</li><li>一般会以预训练得到的为初始参数，再用人工资料进行微调，因为人工成本高且获取资料有限<ul><li>Adapter：在微调时不改变预训练参数，而是在后面直接加上未知项，可以使训练得到的参数与初始参数更接近，同时减小计算量</li></ul></li><li>reinforcement learning from human feedback(RLHF)：由人类对答案进行评分来促使模型微调<ul><li>reward model回馈模型：对输出进行评分</li></ul></li><li>AI agent：让AI能执行多步骤的复杂任务</li><li>image captioning：图像转换为描述性文字</li><li>attention机制：考虑上下文<ul><li>casual attention：在计算每一个token的attention weight时，一般只考虑前文不考虑后文</li><li>multi-head attention：考虑不同关联性给出不同的模组，因此对于一个输入，attention会给出多组输出</li><li>feed forward：将上述得到的多组输出综合考虑，得到一组输出</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch安装及anaconda环境配置问题</title>
    <link href="/2024/11/30/pytorch%E5%AE%89%E8%A3%85%E4%B8%ADis-available-%E4%B8%BAFalse%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2024/11/30/pytorch%E5%AE%89%E8%A3%85%E4%B8%ADis-available-%E4%B8%BAFalse%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="torch-cuda-is-available-为false"><a href="#torch-cuda-is-available-为false" class="headerlink" title="torch.cuda.is_available()为false"></a>torch.cuda.is_available()为false</h2><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>安装了错误的python版本和pytorch版本<br>在安装pytorch时直接将原本代码中的cuda=11.8换成了11.7，殊不知这并不代表能直接安装适用于11.7的版本，而是安装了pytorch v2.5.1这个版本，后来查资料发现适用于11.7的最高版本其实是v2.0.1。<br>安装pytorch v2.0.1时抱错，有一些文件找不到，查资料发现支持pytorch v2.0的最高python版本为3.11。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>请务必先看完再安装！<br>pytorch版本安装错误<br>由于显卡最高支持CUDA v11.7，因此pytorch版本最高为v2.0.1，则python版本最高为v3.11<br>链接1：<a href="https://pytorch.org/get-started/previous-versions/">pytorch下载地址</a> (一定要在这里面看准了CUDA版本下载)<br>链接2：<a href="https://gitcode.com/gh_mirrors/vi/vision/overview?utm_source=csdn_github_accelerator&amp;isLogin=1">pytorch与python版本对应表</a> (在这里面找到对应的python版本)</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.conda</span> create -n pytorch python=<span class="hljs-number">3.11</span> <span class="hljs-comment">//这句创建一个新的环境,python版本为3.11，版本选择一定要参考链接2</span><br>    <span class="hljs-comment">//这里会问是否remove原来创建的，选y</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.conda</span> activate pytorch <span class="hljs-comment">//进入刚刚创建的环境</span><br><span class="hljs-number">3</span><span class="hljs-selector-class">.conda</span> install pytorch==<span class="hljs-number">2.0</span>.<span class="hljs-number">1</span> torchvision==<span class="hljs-number">0.15</span>.<span class="hljs-number">2</span> torchaudio==<span class="hljs-number">2.0</span>.<span class="hljs-number">2</span> pytorch-cuda=<span class="hljs-number">11.7</span> -c pytorch -c nvidia <span class="hljs-comment">//从链接1中复制得到</span><br></code></pre></td></tr></tbody></table></figure><h2 id="python-v3-11安装jupyter不成功问题"><a href="#python-v3-11安装jupyter不成功问题" class="headerlink" title="python v3.11安装jupyter不成功问题"></a>python v3.11安装jupyter不成功问题</h2><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//用以下代码进行安装即可</span><br>conda install -c conda-forge nb_conda<br></code></pre></td></tr></tbody></table></figure><h2 id="pycharm配置conda环境不成功问题"><a href="#pycharm配置conda环境不成功问题" class="headerlink" title="pycharm配置conda环境不成功问题"></a>pycharm配置conda环境不成功问题</h2><p>python版本3.11以上更换最新版本pycharm</p><ol><li>卸载pycharm：卸载报错643的话，需要用版本对应的安装包进行卸载。打开安装包，点击repair进行修复，然后再uninstall进行卸载。</li><li>安装新的pycharm</li></ol><p>增加interpreter</p><ol><li>点击add interpreter</li><li>选择select existing</li><li>type选择conda</li><li>path to conda选择<code>anaconda3\Scripts\conda.exe</code>下的。(注意是conda.exe，有很多相似的很容易弄错)</li><li>environment选择你在conda中创建的环境名称。</li></ol>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>problem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python</title>
    <link href="/2024/11/15/python/"/>
    <url>/2024/11/15/python/</url>
    
    <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li>UTF-8编码中一个汉字占用3个字节</li><li>文件对象的read(n)方法中，传入的形参是n个字符，而不是字节</li><li>且一次read之后的光标移动后，再下一次调用read时光标会保持不变，也就是会接着读</li><li>文件读取时，每一行是作为一个元素读取的，也就是说可以用for遍历每一行</li><li>close函数内置了flush功能</li><li>split、strip函数</li><li>调用不同模块中的同名功能时，后import的会覆盖前者</li><li><strong>name__为内置变量，直接执行时被赋值为__main</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达机器学习</title>
    <link href="/2024/11/09/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/11/09/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息安全技术</title>
    <link href="/2024/11/03/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/11/03/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="信息安全与密码学"><a href="#信息安全与密码学" class="headerlink" title="信息安全与密码学"></a>信息安全与密码学</h2><h3 id="密码技术发发展简介"><a href="#密码技术发发展简介" class="headerlink" title="密码技术发发展简介"></a>密码技术发发展简介</h3><ul><li>信息安全主要包括系统安全及数据安全。<ul><li>系统安全：一般采用防火墙、病毒查杀等被动措施。</li><li>数据安全：采用密码技术对己方信息的完整性、保密性与可用性进行主动保护。</li></ul></li></ul><h4 id="古典密码技术"><a href="#古典密码技术" class="headerlink" title="古典密码技术"></a>古典密码技术</h4><ul><li>早期的密码技术主要以字母的代替以及字母的位移为主。可以采用频率分析破译单字母代换密码。</li><li>16世纪，Vigenere密码，一种多字母代换密码。仍可以采用频率分析破译。</li><li>Playfair或ADFGVX，多字母代换与移位结合产生密码。</li><li>一次一密密码(One-Time-Pad)，每加密一次就要用不同的密钥，无法破译但成本极高。</li><li>滚轮编码(Rotor Machine)，拥有的密钥数量极多，无法用传统的频率分析法破译。</li></ul><h4 id="现代密码技术"><a href="#现代密码技术" class="headerlink" title="现代密码技术"></a>现代密码技术</h4><ul><li>香农发表的《保密系统的通信理论》标志着现代密码学开始。首次将信息论引入，利用概率统计的观点和熵的概念对信息源、密钥源、传输的密文和密码系统的安全性进行了数学描述和定量分析，提出了<strong>对称密码体制</strong>的模型。<br>数据加密标准(DES)，高级加密标准(AES)完全公开了加密、解密算法，使得密码学得以在商业等民用领域广泛应用。</li><li>公钥密码体制。将加密密钥像电话簿一样公开。</li><li>RSA公钥密码体制，基于数论种的大整数因子分解。</li></ul><h3 id="密码学的基本概念"><a href="#密码学的基本概念" class="headerlink" title="密码学的基本概念"></a>密码学的基本概念</h3><ul><li>包括两个分支<ul><li>密码编码学：研究对信息进行变化，以保护信息在信道的传递过程中不被敌手窃取、解读和利用的方法。</li><li>密码分析学：研究如何分析和破译密码。</li></ul></li></ul><h4 id="密码系统的组成"><a href="#密码系统的组成" class="headerlink" title="密码系统的组成"></a>密码系统的组成</h4><ul><li>一个密码系统是由密码方案确定的一簇映射，将明文空间中的每一个元素映射到密文空间上的某个元素，使用哪一个映射由密钥决定。可以用一个五元组S={M,C,K,E,D}来描述：<ul><li>明文空间M：全体明文的集合。</li><li>密文空间C：全体密文的集合。</li><li>密钥空间K：全体密钥的集合，k=&lt;k<del>e</del>,k<del>d</del>&gt;，k<del>e</del>和k<del>d</del>可能相同也可能不同。<ul><li>k<del>e</del>：加密密钥</li><li>k<del>d</del>：解密密钥</li></ul></li><li>加密算法E：由加密密钥控制的加密变换的集合。</li><li>解密算法D：由解密密钥控制的解密变换的集合。</li><li>加密函数E<del>k~~e</del>：使得c=E<del>k~~e</del>(m)</li><li>解密函数D<del>k~~d</del>：使得m=D<del>k~~d</del>(c)，E<del>k~~e</del>和D<del>k~~d</del>作用相互抵消。</li></ul></li><li>攻击手段：<ul><li>主动攻击：非授权者采用删除、更改、增添、重放、伪造等手段主动向系统注入虚假信息。会损害明文信息的完整性。采用鉴别与认证机制，数字签名与散列函数(鉴别码)。</li><li>被动攻击：非授权者采用电磁侦听、声音窃听、搭线窃听等方法直接得到未加密的明文或加密后的密文。会损害明文信息的机密性。使用密码算法进行加密。</li></ul></li><li>一个密码系统是实用的：<ul><li>加密函数和解密函数能有效地被计算。</li><li>攻击者即使接收到密文，想确定出所用的密钥或明文也是不可行的。</li></ul></li></ul><h4 id="密码体制的分类"><a href="#密码体制的分类" class="headerlink" title="密码体制的分类"></a>密码体制的分类</h4><ul><li>根据加密算法与解密算法所用密钥是否相同：<ul><li>对称密码体制：k<del>e</del>=k<del>d</del>。也叫单密钥体制、秘密密钥密码体制。一般基于复杂的非线性变换。</li><li>非对称密码体制：k<del>e</del>≠k<del>d</del>。也叫双密钥体制、公开密钥密码体制。每个用户都有一对选定的密钥，其中一个是可以公开的，另一个由用户自己秘密保存。一般基于数学上的难题事先。保密强度更弱，适用于开放环境，密钥管理简单，可以方便、安全地实现数字签名和认证。</li></ul></li><li>根据密码算法对明文信息地处理方法：<ul><li>流密码：逐位或逐字节加密明文消息字符，也称序列密码。</li><li>分组密码：将明文分成固定长度的组，用同一密钥和算法加密，输出固定长度的密文。<em>大多数现有公开密钥体制都属于分组密码</em></li></ul></li><li>根据是否能进行可逆的加密变换：<ul><li>单向函数密码体制：明文转密文很容易，密文转明文很困难甚至是不可能的。只适用于不需要解密的场合(密钥管理、信息完整性鉴别技术等)</li><li>双向变换密码体制。</li></ul></li></ul><h4 id="密码系统的安全性"><a href="#密码系统的安全性" class="headerlink" title="密码系统的安全性"></a>密码系统的安全性</h4><ul><li>Kerckhoffs原理：在密码算法的分析当中，一般先假设密码攻击者了解密码方案的全部知识，可以得到相当数量的密文，知道明文的统计特性和密钥的统计特性，但不知道每一个密文c所用的特定的密钥k，这时整个密码系统的安全性全部寄托于密钥的保密上，即<em>一切秘密寓于密钥之中</em>。换句话说，密钥应该是整个密码体制的核心所在，密码体制的安全性应该建立在密钥的基础上，而不是依赖于密码算法的隐藏。</li><li>密码系统安全性的评估方法：<ul><li>无条件安全性：无论攻击者获得多少密文也求不出确定明文的足够信息，理论上不可破译，也称理论安全性。</li><li>实际安全性：<ul><li>计算安全性：原则上虽可破译，但需付出十分巨大的计算，不能在有效时间/成本内计算得到。</li><li>可证明安全性：可转换为密码研究人员公认的难题。</li><li>达到实际安全性的准则：<ul><li>计算量巨大，实际上不可实现。</li><li>破译时间超过被加密信息的有用生命周期。</li><li>破译费用超过信息本身价值。</li></ul></li></ul></li></ul></li><li>密码系统的安全因素：<ul><li>密码算法的保密强度：取决于密码设计的水平、破译技术的水平和攻击者对于加密系统知识的多少。</li><li>其他非技术手段(如收买管理人员)攻破密码系统。</li></ul></li></ul><h4 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h4><ul><li>密码分析的类型：<em>强度逐渐递增</em><ul><li>纯密文攻击：攻击者手中除了密文外无其他信息。</li><li>已知明文攻击：除了密文还掌握了部分明文与密文的对应关系。</li><li>选择明文攻击：知道加密算法，能够选择明文并得到相应明文所对应的密文。</li><li>选择密文攻击：知道加密算法，选择一些对攻击有利的特定密文，并将密文破译成对应的明文。攻击者的目标通常是加密过程中使用的密钥。</li></ul></li><li>密码分析的方法<ul><li>穷举攻击法：采用扩大密钥空间或提高加密、解密算法复杂度来对抗。每次破解需要付出高昂的计算代价。<ul><li>穷举密钥：某个解密密钥能产生有意义的明文则是正确的。</li><li>穷举明文：保持加密密钥不变，对可能明文进行加密，若加密得到的密文与截获的密文一致，则是正确的。</li></ul></li></ul></li><li>统计分析法：获得密文的统计规律，再将此规律与已知明文的统计规律对照比较。设计密码系统时避免密文和明文在统计规律上的一致来对抗。</li><li>数学分析法：针对密码系统的数学基础和密码学特性，比如明文和密文的对应关系求解。对于基于数学难题的密码系统，数学分析法是一种重要的破解手段。</li></ul><h3 id="古典密码体制"><a href="#古典密码体制" class="headerlink" title="古典密码体制"></a>古典密码体制</h3><h4 id="代换密码系统"><a href="#代换密码系统" class="headerlink" title="代换密码系统"></a>代换密码系统</h4><ul><li>在加密时将明文消息划分成长为L的消息单元，称为明文组，以m表示，也称m为L-报文(L=1为单字母报文)。</li><li>密文则用L’。一般明文和密文由同一字母表构成。<ul><li>此时若L=L’，则代换映射是一一映射，密码无数据拓展。</li><li>若L＜L’，则有数据拓展，可将加密函数设计成一对多的映射，即明文组可以找到多于一个密文组来代换，称为<strong>多名(同音)代换密码</strong>。</li><li>若L＞L’，则明文数据被压缩，密文无法被恢复成明文。</li></ul></li></ul><h5 id="单表代换密码"><a href="#单表代换密码" class="headerlink" title="单表代换密码"></a>单表代换密码</h5><p>对明文的所有字母都用一个固定的明文字母表到密文字母表的映射</p><ul><li>移位密码：基于模运算。将字母表中的26个字母都编码为数字，然后加k进行mod26运算。如恺撒密码。很不安全，可以直接穷举分析。</li><li>代换密码：代换字母与原字母一一对应，但是随机对应的，而不是顺序对应的。共有26！个密钥。</li><li>仿射密码：加密函数(ax+b)mod26。密钥空间为12*26=312。</li></ul><h5 id="多表代换密码"><a href="#多表代换密码" class="headerlink" title="多表代换密码"></a>多表代换密码</h5><p>以一系列代换表依次对明文消息的字母进行代换的加密方法。若f是非周期的无线序列，则对应的密码称为非周期多表代换密码。这类密码对每个明文字母都采用不同的代换表进行加密，称为一次一密密码。但由于需要的密钥量和明文消息长度相同而难以广泛使用。</p><ul><li>Vigenere密码(维吉尼亚密码)：给定一个m长的密钥k，k中有m个数。将明文串按m一组分段，然后逐段使用密钥字k。eg：c<del>1</del>=(x<del>1</del>+k<del>1</del>)mod26。该密钥空间大小为26^m^。</li></ul><h5 id="多字母代换密码"><a href="#多字母代换密码" class="headerlink" title="多字母代换密码"></a>多字母代换密码</h5><p>每次对L＞1个字母进行代换，可以很容易将字母的频率信息隐蔽或均匀化。</p><ul><li>希尔密码：对于m≥2，y=xk，其中y、x、k都是m*m矩阵。</li></ul><h4 id="置换密码系统"><a href="#置换密码系统" class="headerlink" title="置换密码系统"></a>置换密码系统</h4><p>保持明文的所有字母不变，利用置换打乱明文字母的位置和次序。也称换位密码。</p><h2 id="对称密码体系"><a href="#对称密码体系" class="headerlink" title="对称密码体系"></a>对称密码体系</h2><h3 id="对称密码体系概述"><a href="#对称密码体系概述" class="headerlink" title="对称密码体系概述"></a>对称密码体系概述</h3><p>对称密码算法也称传统密码算法、单钥密码算法，它包括许多数据加密方法。</p><ul><li>基本特征：加密和解密使用同一个密钥。</li><li>安全性取决于密钥的保密性而不是算法的机密性。</li><li>优点：效率高、速度快。</li><li>缺点：密钥管理复杂，N个用户需要N(N-1)把密钥。</li></ul><h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><ul><li>优点：实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播等。</li><li>当密钥流序列是由无记忆离散的二进制均匀分布信源产生的随机序列时，产生该序列的密码就是“一次一密”密码。但要求密钥数量与明文数量一致，不方便存储和分配，因此目前都是用一个短的密钥生成一个周期长且安全的密钥流。</li></ul><h4 id="流密码的结构"><a href="#流密码的结构" class="headerlink" title="流密码的结构"></a>流密码的结构</h4><h5 id="同步流密码"><a href="#同步流密码" class="headerlink" title="同步流密码"></a>同步流密码</h5><ul><li>密码流的产生独立于明文和密文。发送方和接收方只要由相同的密钥和初始内部状态，就能产生相同的密钥流。</li><li>每个密文字符都不依赖于之前的明文，因此无错误传播，即密文字符的改变只影响该符号的恢复，不会对后继符号产生影响。</li><li>必须保证发送方和接收方是同步的，用同样的密钥且密钥操作在同样的位置时才能保证正确解密。</li></ul><h5 id="自同步流密码"><a href="#自同步流密码" class="headerlink" title="自同步流密码"></a>自同步流密码</h5><ul><li>密码流的产生与已生成的密文有关。</li><li>若密码流中某一符号出现传输错误，将影响到它之后k个符号的解密运算。等到该错误移出寄存器后才能恢复同步。</li></ul><h5 id="反馈移位寄存器与线性反馈移位寄存器"><a href="#反馈移位寄存器与线性反馈移位寄存器" class="headerlink" title="反馈移位寄存器与线性反馈移位寄存器"></a>反馈移位寄存器与线性反馈移位寄存器</h5><h6 id="反馈移位寄存器"><a href="#反馈移位寄存器" class="headerlink" title="反馈移位寄存器"></a>反馈移位寄存器</h6><ul><li>a：存储单元，取值为0或1，a<del>i</del>的个数n称为反馈移位寄存器的级。</li><li>在某一时刻，这些级的内容构成该反馈移位寄存器的一个状态，共有2^n^个可能的状态。</li><li>每一时刻存储器上的值都会作为输入值输入反馈函数f中，得到的输出作为新的值传入寄存器中。</li></ul><h6 id="线性反馈移位寄存器"><a href="#线性反馈移位寄存器" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h6><p>对于反馈函数中每一级相异或的系数为0或1时，称为线性反馈移位寄存器(LFSR)。</p><h5 id="m序列及其伪随机性"><a href="#m序列及其伪随机性" class="headerlink" title="m序列及其伪随机性"></a>m序列及其伪随机性</h5><h6 id="m序列与最长线性移位寄存器"><a href="#m序列与最长线性移位寄存器" class="headerlink" title="m序列与最长线性移位寄存器"></a>m序列与最长线性移位寄存器</h6>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题记录</title>
    <link href="/2024/10/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/10/05/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>刷题好痛苦，题目看都看不懂，一道题写个三四个小时都写不出来<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>有时候看了大佬的思路都复现不了，太打击人了。</p><ul><li>二分法：有序数组的查找用二分法，时间复杂度为O(logn)。</li><li>双指针：有序数组的查找并增删</li><li>滑动窗口：</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown问题汇总</title>
    <link href="/2024/10/03/markdown%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/10/03/markdown%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<ul><li>常用指令：<ul><li>hexo new “”：创建新文本</li><li>hexo g 生成</li><li>hexo d 推送</li></ul></li><li>加粗问题：结尾**符号之前有标点符号时，**之后要加一个空格</li><li>换行问题：正常文本中直接回车就会换行，但在admonition中需要用&lt;br&gt;换行。待解决···</li><li>时间问题：可以通过直接修改文章开头date后面是时间来修改文章发布的次序</li></ul>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>problem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决用leancloud给fluid增加访问量和评论功能时无法加载和显示的问题</title>
    <link href="/2024/09/29/%E5%A2%9E%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E5%8A%9F%E8%83%BD-md/"/>
    <url>/2024/09/29/%E5%A2%9E%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E5%8A%9F%E8%83%BD-md/</url>
    
    <content type="html"><![CDATA[<p>2022年LeanCloud 国际版不再为来自中国大陆的 IP 提供服务，基于 LeanCloud 的站点统计因此失效，使用LeanCloud统计时无显示，但使用梯子后是正常显示的，因此改用LeanCloud国内版即可。</p><p>剩下的操作可以直接参考<a href="http://minghuijia.cn/2022/03/14/Hexo-fluid%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E7%BB%9F%E8%AE%A1%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E9%87%8F/">链接</a></p><p>补充：修改_config.fluid.yml</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"># REST API 服务器地址，国际版不填<br># Only the Chinese mainland users need to set<br>server_url: //将LeanCloud中的REST API复制过来<br></code></pre></td></tr></tbody></table></figure><p>So easy！但是花了我一个晚上加一个下午<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>更新：发现评论功能不挂梯子还是用不了，好像需要买个域名DNS解析到国内服务器上，好麻烦，先选择性放弃一下。</p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>problem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-admonition插件安装无显示且显示异常问题</title>
    <link href="/2024/09/28/hexo-admonition%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/28/hexo-admonition%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>耗时两个小时解决，主要花在了找资料和理解上<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>大多数人用的是Mkdocs框架，包括用vscode预览时也是，但本人用的是Hexo框架，这就导致了一开始找到的资料都不太有用。且对于CSS文件了解不多，最后是在官方手册找到的解决方法。</p><h2 id="镜像源失效"><a href="#镜像源失效" class="headerlink" title="镜像源失效"></a>镜像源失效</h2><p><code>npm ERR! code ECONNRESET //等一长串error</code></p><p>要解决该问题，需要重置镜像源</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">npm config set proxy null 重置代理<br>npm config set registry https://registry.npmmirror.com 更换源(仍然报错expired的话继续换源，直接搜索hexo镜像源即可)<br></code></pre></td></tr></tbody></table></figure><h2 id="修改CSS文件"><a href="#修改CSS文件" class="headerlink" title="修改CSS文件"></a>修改CSS文件</h2><p>安装完插件之后发现并没有按照预期显示，且attention等标签用不了。上传到GitHub后显示如下图<br><img src="https://raw.githubusercontent.com/zhongyebb/picture-gallery/main/blogs/pictures/20240928172150.png" alt="20240928172150" title="attention标签显示异常"></p><p>解决该问题，首先在public/CSS文件夹中创建一个自定义CSS文件my.css，并将下列代码复制进去</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs text">.admonition {<br>  margin: 1.5625em 0;<br>  padding: .6rem;<br>  overflow: hidden;<br>  font-size: .64rem;<br>  page-break-inside: avoid;<br>  border-left: .3rem solid #42b983;<br>  border-radius: .3rem;<br>  box-shadow: 0 0.1rem 0.4rem rgba(0,0,0,.05), 0 0 0.05rem rgba(0,0,0,.1);<br>  background-color: #fafafa;<br>}<br><br>p.admonition-title {<br>  position: relative;<br>  margin: -.6rem -.6rem .8em -.6rem !important;<br>  padding: .4rem .6rem .4rem 2.5rem;<br>  font-weight: 700;<br>  background-color:rgba(66, 185, 131, .1);<br>}<br><br>.admonition-title::before {<br>  position: absolute;<br>  top: .9rem;<br>  left: 1rem;<br>  width: 12px;<br>  height: 12px;<br>  background-color: #42b983;<br>  border-radius: 50%;<br>  content: ' ';<br>}<br><br>.info&gt;.admonition-title, .todo&gt;.admonition-title {<br>  background-color: rgba(0,184,212,.1);<br>}<br><br>.warning&gt;.admonition-title, .attention&gt;.admonition-title, .caution&gt;.admonition-title {<br>  background-color: rgba(255,145,0,.1);<br>}<br><br>.failure&gt;.admonition-title, .missing&gt;.admonition-title, .fail&gt;.admonition-title, .error&gt;.admonition-title {<br>  background-color: rgba(255,82,82,.1);<br>}<br><br>.admonition.info, .admonition.todo {<br>  border-color: #00b8d4;<br>}<br><br>.admonition.warning, .admonition.attention, .admonition.caution {<br>  border-color: #ff9100;<br>}<br><br>.admonition.failure, .admonition.missing, .admonition.fail, .admonition.error {<br>  border-color: #ff5252;<br>}<br><br>.info&gt;.admonition-title::before, .todo&gt;.admonition-title::before {<br>  background-color: #00b8d4;<br>  border-radius: 50%;<br>}<br><br>.warning&gt;.admonition-title::before, .attention&gt;.admonition-title::before, .caution&gt;.admonition-title::before {<br>  background-color: #ff9100;<br>  border-radius: 50%;<br>}<br><br>.failure&gt;.admonition-title::before,.missing&gt;.admonition-title::before,.fail&gt;.admonition-title::before,.error&gt;.admonition-title::before{<br>  background-color: #ff5252;;<br>  border-radius: 50%;<br>}<br><br>.admonition&gt;:last-child {<br>  margin-bottom: 0 !important;<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后修改_config.fluid.yml文件<br><code>custom_css: /css/my.css</code></p><p>最后重新上传即可<br>有用的话请点个<span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，非常感谢！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/qq_16785561/article/details/140782167">安装报错</a><br><a href="https://github.com/lxl80/hexo-admonition?tab=readme-ov-file">hexo-admonition插件</a></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>problem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法笔记</title>
    <link href="/2024/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><strong>数据结构与算法</strong>：是一门研究非数值计算的程序设计中计算机的操作对象以及他们之间的关系和操作的学科。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>是输入计算机且被计算机处理的各种符号的集合，是信息的载体。</p><ul><li><strong>数据元素（元素）</strong>：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。也可称为记录、结点或顶点。</li><li><strong>数据项</strong>：构成数据元素的不可分割的最小单位。</li><li><strong>数据对象</strong>：性质相同的数据元素的集合，是数据的一个子集。</li></ul><div class="admonition note"><p class="admonition-title">note</p><p>数据&gt;数据对象&gt;数据元素&gt;数据项</p></div><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据元素相互之间的关系称为结构，是指相互之间存在一中或多种特定关系的数据元素集合。</p><ul><li><p><strong>逻辑结构</strong>：数据元素之间的逻辑关系，即从具体问题中抽象出来的数学模型。</p><ul><li><strong>线性结构</strong>：有且仅有一个开始和一个终端结点。<em>线性表、栈、队列、串等</em></li><li><strong>非线性结构</strong>：一个结点可能有多个直接前趋和直接后继。<em>树、图、网等</em></li></ul></li><li><p><strong>物理结构（存储结构）</strong>：数据元素及其在计算机内存中的表示（又称为映像）。</p><ul><li><strong>顺序存储结构</strong>：用一组连续的存储单元依次存储数据元素，元素的存储位置表示逻辑关系。<em>如数组</em></li><li><strong>链接存储结构</strong>：用一组任意的存储单元存储数据元素，在存储数据的同时存储下一个数据的地址。<em>如指针</em></li><li><strong>索引存储结构</strong>：在存储节点信息的同时，还建立附加的索引表。<em>如通讯录</em></li><li><strong>散列存储结构</strong>：根据节点的关键字直接计算出该节点的存储地址。</li></ul></li><li><p><strong>数据的运算和实现</strong>：对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</p></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>一组性质相同的值的集合，以及定义于这个值集合上的一组操作的总称。<em>如int、char、数组等</em></p><ul><li><p><strong>作用</strong>：约束变量的取值范围和操作。</p></li><li><p><strong>抽象数据类型（ADT）</strong>：从问题抽象出的一个数学模型以及定义的操作（抽取共同点），用三元组（D、S、P）表示。<em>如c++中的类</em></p><ul><li>D：数据对象</li><li>S：数据关系</li><li>P：基本操作</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zhongyebb/picture-gallery/main/blogs/pictures/20240928110706.png" alt="20240928110706" title="基本概念总结图"></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>对特定问题求解方法和步骤的描述。是指令的有限序列，其中每个指令表示一个或多个操作。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>有穷性</strong>：执行步骤和时间是有限的。</li><li><strong>确定性</strong>：每一条指令有确切含义，没有二义性。只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</li><li><strong>可行性</strong>：可执行的，可以通过已经实现的基本操作执行有限次来实现。</li><li><strong>输入</strong>：有零个或多个输入。</li><li><strong>输出</strong>：有一个或多个输出。</li></ul><div class="admonition attention"><p class="admonition-title">attention</p><p>输入可以没有但输出至少一个</p></div><h4 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h4><ul><li><strong>正确性（Correctness）</strong>：无语法错误，任意输入的结果正确，即对于某些典型的、苛刻且带有刁难性的输入能得到正确结果。</li><li><strong>可读性（Readability）</strong>：便于理解和交流，方便调试。</li><li><strong>健壮性（Robustness）</strong>：有些地方会翻译成鲁棒性。指当输入非法数据时，算法会做出恰当反应并合理处理。</li><li><strong>高效性（Efficiency）</strong>：时间少，存储低。<ul><li>时间效率：算法所耗费的时间，有两种度量方法<ul><li>事后分析：算法实现后，实际运行来进行测量。需要花费较多时间和精力，且与软硬件性能有关。</li><li>事前分析：直接对消耗资源进行估算。</li></ul></li><li>空间效率：算法执行过程中耗费的存储空间<br>一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率。</li></ul></li></ul><h4 id="时间效率的计算"><a href="#时间效率的计算" class="headerlink" title="时间效率的计算"></a>时间效率的计算</h4><ul><li><code>算法运行时间=一个简单操作所需要的时间×简单操作的次数</code></li><li>语句频度：每条语句的执行次数<br>则<code>算法运行时间=Σ(语句频度×该语句执行一次所需的时间)</code>。假设执行每条语句所需的时间均为单位时间，则可转化为讨论该算法中所有语句的执行次数，即<strong>频度之和</strong></li></ul><blockquote><p><strong>例1：两个n×n的矩阵相乘</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//执行n+1次，最后一次判断并推出</span><br>  <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++){ <span class="hljs-comment">//n(n+1)</span><br>    c[i][j]=<span class="hljs-number">0</span>; <span class="hljs-comment">//n*n</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;n;k++) <span class="hljs-comment">//n*n*(n+1)</span><br>      c[i][j]=c[i][j]+a[i][k]*b[k][j]; <span class="hljs-comment">//n*n*n</span><br>  }<br><span class="hljs-comment">//则时间消耗T(n)=2n^3^+3n^2^+2n+1</span><br></code></pre></td></tr></tbody></table></figure></blockquote><div class="admonition note"><p class="admonition-title">note</p><ul><li>一般直接用<strong>最大数量级</strong>进行比较，即算法的渐进时间复杂度，简称<strong>时间复杂度</strong>，记为<strong>O(f(n))</strong>。</li><li>在计算数量级的时候，不需要考虑所有语句，只考虑贡献最大的语句即可，即执行次数最多的语句，称该语句为<strong>基本操作</strong>。</li><li><em>在例1中时间复杂度为n^3^，即T(n)=O(n^3^)</em>。</li></ul></div><p><img src="https://raw.githubusercontent.com/zhongyebb/picture-gallery/main/blogs/pictures/20241002160101.png" alt="20241002160101" title="例2 时间复杂度的计算"></p><h5 id="时间复杂度与输入数据集有关时"><a href="#时间复杂度与输入数据集有关时" class="headerlink" title="时间复杂度与输入数据集有关时"></a>时间复杂度与输入数据集有关时</h5><ul><li><strong>最坏时间复杂度</strong>：指在最坏情况下的时间复杂度</li><li><strong>最好时间复杂度</strong>：指在最好情况下的时间复杂度</li><li><strong>平均时间复杂度</strong>：所有可能输入实例等概率出现时，算法的期望运行时间</li></ul><div class="admonition note"><p class="admonition-title">note</p><p>一般考虑<strong>最坏时间复杂度</strong>。</p></div><h5 id="复杂算法时间复杂度的计算"><a href="#复杂算法时间复杂度的计算" class="headerlink" title="复杂算法时间复杂度的计算"></a>复杂算法时间复杂度的计算</h5><ul><li>加法规则：若可以将算法分解为多个函数相加，则取其中最大的一个数量级</li><li>乘法规则：若可以将算法分解为多个函数相乘，则将所有函数的时间复杂度相乘。</li></ul><h5 id="时间效率的比较"><a href="#时间效率的比较" class="headerlink" title="时间效率的比较"></a>时间效率的比较</h5><p>复杂度由低到高</p><table><thead><tr><th>常数阶</th><th>对数阶</th><th>线性阶</th><th>线性对数阶</th><th>平方阶</th><th>立方阶</th><th>指数阶</th><th>阶乘阶</th></tr></thead><tbody><tr><td>O(1)</td><td>O(logn)</td><td>O(n)</td><td>O(nlogn)</td><td>O(n^2^)</td><td>O(n^3^)</td><td>O(2^n^)</td><td>O(n!)</td></tr></tbody></table><h4 id="空间效率的计算"><a href="#空间效率的计算" class="headerlink" title="空间效率的计算"></a>空间效率的计算</h4><ul><li>渐进空间复杂度：算法所需存储空间的度量，记为S(n)。</li><li>算法要占据的空间包括：输入输出、指令、常数、变量等，以及要使用的辅助空间。</li></ul><blockquote><p><strong>例3：将一组数组a中的n个数逆序存放到原数组中</strong><br>算法1 需要t作为辅助空间 S(n)=O(1) <em>常数阶称为原理工作</em></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++){<br> t=a[i];<br> a[i]=a[n-i<span class="hljs-number">-1</span>];<br> a[n-i<span class="hljs-number">-1</span>]=t;<br>&gt;}<br></code></pre></td></tr></tbody></table></figure><p>算法2 需要b[n]作为辅助空间 S(n)=O(n)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br> b[i]=a[n-i<span class="hljs-number">-1</span>];<br>&gt;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br> a[i]=b[i];<br></code></pre></td></tr></tbody></table></figure></blockquote><h2 id="逻辑结构的种类"><a href="#逻辑结构的种类" class="headerlink" title="逻辑结构的种类"></a>逻辑结构的种类</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="定义及特性"><a href="#定义及特性" class="headerlink" title="定义及特性"></a>定义及特性</h4><ul><li>具有<strong>相同特性</strong>的数据元素（结点）的一个<strong>有限</strong>序列，元素之间的关系是线性关系。</li><li><strong>起始结点</strong>：线性表中的第一个数据元素，也称首元。</li><li><strong>终端节点</strong>：线性表中的最后一个数据元素。</li><li>对于某个内部节点a<del>i</del>，称a<del>i-1</del>为<strong>直接前趋</strong>，a<del>i+1</del>为<strong>直接后继</strong>。</li><li>下标是元素的序号，用于表示元素在表中的位置。</li><li><strong>表长</strong>：表的长度，即元素总个数，一般用n表示。<em>n=0时称为空表</em></li></ul><div class="admonition attention"><p class="admonition-title">attention</p><p>线性表的逻辑特征为线性关系，具体体现为每一个元素都<strong>最多</strong>只有一个直接前趋和直接后继。首元无前趋，末尾无后继。</p></div><blockquote><p><strong>例1：稀疏多项式的存储</strong><br>可以只储存有系数的多项式而不用全部储存，只需将系数和项的次数同时储存即可。<br>但用顺序存储结构，在进行多项式加法时需要遍历计算再存储，且用于储存新生成多项式的数组大小不确定。<em>此时可以考虑采用链式存储结构</em>。</p></blockquote><h4 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h4><ul><li>基本操作</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">InitList(&amp;L) <br>  <span class="hljs-comment">//构造一个空的线性表（构造函数）</span><br>DestroyList(&amp;L) <br>  <span class="hljs-comment">//判断线性表是否存在</span><br>  <span class="hljs-comment">//若存在则销毁线性表</span><br>ClearList(&amp;L) <br>  <span class="hljs-comment">//判断线性表是否存在</span><br>  <span class="hljs-comment">//若存在则将线性表置为空表</span><br>ListEmpty(L) <br>  <span class="hljs-comment">//判断线性表是否存在</span><br>  <span class="hljs-comment">//若存在则将判断线性表是否为空，是则返回TRUE，否则返回FALSE</span><br>ListLength(L) <br>  <span class="hljs-comment">//判断线性表是否存在</span><br>  <span class="hljs-comment">//若存在则返回线性表中的元素个数</span><br>GetElem(L,i,&amp;e) <br>  <span class="hljs-comment">//线性表存在，且1&lt;=i&lt;=ListLength(L)</span><br>  <span class="hljs-comment">//用e返回线性表L中第i个数据元素的值</span><br>LocateElem(L,e,compare())<br>  <span class="hljs-comment">//线性表存在，compare()是数据元素的判断函数(大于，小于，等于···)</span><br>  <span class="hljs-comment">//返回L中第1个与e满足compare()的数据元素的位序，若不存在这样的元素则返回0</span><br>PriorElem(L,cur_e,&amp;pre_e)<br>  <span class="hljs-comment">//线性表存在</span><br>  <span class="hljs-comment">//若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前趋；否则pre_e无意义</span><br>NextElem(L,cur_e,&amp;next_e)<br>  <span class="hljs-comment">//线性表存在</span><br>  <span class="hljs-comment">//若cur_e是L的数据元素，且不是最后一个，则用pre_e返回它的后继；否则pre_e无意义</span><br>ListInsert(&amp;L,i,e)<br>  <span class="hljs-comment">//线性表存在，且1&lt;=i&lt;=ListLength(L)+1</span><br>  <span class="hljs-comment">//在L的第i个位置之前插入新的数据元素e，L的长度加1</span><br>ListDelete(&amp;L,i,&amp;e)<br>  <span class="hljs-comment">//线性表存在，且1&lt;=i&lt;=ListLength(L)</span><br>  <span class="hljs-comment">//删除L的第i个数据元素，并用e返回其值，L的长度减1</span><br>ListTraverse(&amp;L,visited())<br>  <span class="hljs-comment">//线性表存在</span><br>  <span class="hljs-comment">//遍历函数，对线性表中每一个元素调用visited()</span><br></code></pre></td></tr></tbody></table></figure><h4 id="顺序表示和实现-随机存取法"><a href="#顺序表示和实现-随机存取法" class="headerlink" title="顺序表示和实现(随机存取法)"></a>顺序表示和实现(随机存取法)</h4><ul><li>典型的线性表顺序存储结构：依次存储，地址<strong>连续</strong>。则知道一个元素的存储位置就可以计算其他元素的存储位置。<em>如数组</em></li><li>若地址不连续，即中间存在空的存储单元，则不是一个线性表顺序存储结构。</li><li>优点：<ul><li>随机存取，即每一个元素的位置都能直接计算得到，且运算的时间复杂度为O(1)，与储存的元素个数无关。</li><li>存储密度大，等于1。</li></ul></li><li>缺点：<ul><li>无法随机存储，增删时都需要移动大量元素，时间复杂度为O(n)。</li><li>静态存储，无法自由扩充元素个数，会导致限制或溢出。</li></ul></li></ul><div class="admonition note"><p class="admonition-title">note</p><p>存储密度 = 结点数据内容占用的空间/结点占用的空间总量</p></div><ul><li>线性表的数据类型：线性表的表长是可变的，但数组的长度是不可变的，因此需要用一个变量表示顺序表的长度属性，如下</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">define LIST_INIT_SIZE <span class="hljs-number">100</span> <span class="hljs-comment">//线性表存储空间的初始分配量，即可能达到的最大长度</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br>  ElemType elem[LIST_INIT_SIZE]; <span class="hljs-comment">//ElemType为元素类型</span><br>  <span class="hljs-type">int</span> length; <span class="hljs-comment">//当前长度</span><br>}SqList<br></code></pre></td></tr></tbody></table></figure><div class="admonition attention"><p class="admonition-title">attention</p><ul><li>逻辑位序与物理位序相差1，即数组第一个元素实际是存放在下标为0的位置</li><li><code>ElemType data[MaxSize]</code> 数组是静态分配的</li><li><code>ElemType *data</code> 数组是动态分配的，用malloc函数分配 <code>L.data = (ElemType*)malloc(sizeof(ElemType)*MaxSize) //(ElemType*)将返回值强制转换为括号内类型</code>data中存放的都是数组的首地址。</li></ul></div><h5 id="类C语言的补充"><a href="#类C语言的补充" class="headerlink" title="类C语言的补充"></a>类C语言的补充</h5><blockquote><ul><li>c语言中动态分配会用到的函数，包含在头文件&lt;stdlib.h&gt;中<ul><li>malloc(m)函数：开辟m字节长度的地址空间，并返回这段空间的首地址</li><li>sizeof(x)函数：返回变量x的长度</li><li>free(p)函数：释放指针p所指的存储空间，即彻底删除一个变量</li></ul></li><li>c++中动态分配会用到的函数<ul><li>new 类型名T(初值列表)：申请用于存放T类型对象的内存空间，并依初值列表赋以初值(初值列表可省略)。成果则返回新分配的内存地址，是一个T类型的指针；失败则返回NULL(0)。</li><li>delete 指针p：用于释放new分配的指针所指向的地址。</li></ul></li><li>函数的参数传递<ul><li>传值：形参(函数内的临时变量)操作不影响实参</li><li>传地址：形参操作可以影响实参<br>分为三种，指针、数组名和引用，三者其实都是一个指针。<ul><li>其中引用为<code>int &amp;j = i</code>，称j为i的引用，二者共用一个地址，可以将j看作一个常量指针，指向i所在地址。</li><li>但引用类型作形参，在内存中并没有产生实参的副本，而是直接对实参操作，因此对比值传递，引用传递的时间和空间效率更好。</li><li>对比指针传递，在被调用函数中需要反复使用解引用运算符*，容易出错且阅读性较差。</li></ul></li></ul></li></ul></blockquote><h5 id="常用预定义常量的补充"><a href="#常用预定义常量的补充" class="headerlink" title="常用预定义常量的补充"></a>常用预定义常量的补充</h5><blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> INFEASIBLE -1 <span class="hljs-comment">//不可行的</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><br>&gt;<span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status <span class="hljs-comment">//值是函数结果状态代码，不一定是int，与返回值有关</span><br>&gt;<span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ELemType <span class="hljs-comment">//不一定是char，取决于数据域类型</span><br></code></pre></td></tr></tbody></table></figure></blockquote><h5 id="线性表-基本操作的代码实现"><a href="#线性表-基本操作的代码实现" class="headerlink" title="(线性表)基本操作的代码实现"></a>(线性表)基本操作的代码实现</h5><p>PS：<em>王卓老师这里讲了一些基本操作的代码实现，讲的很具体。因为已经学过C++我就直接忽略了，有需要的可以去看网课P17-220，这里只补充一些知识点</em>  </p><ul><li><strong>平均查找长度(ASL)</strong> ：Locate函数的平均时间复杂度，即需要与给定值进行比较的次数的期望值。<code>ASL=Σ^n^~i=1~P~i~*C~i~</code>，其中P<del>i</del>为第i个元素被查找的概率，C<del>i</del>为找到第i个记录需比较的次数。</li><li>插入元素时要保证数组连续，因此要从最后一个开始，一个接一个往后移。还要确保不会溢出。</li></ul><div class="admonition note"><p class="admonition-title">note</p><ul><li>顺序表的ASL=(n+1)/2</li><li>插入函数的平均时间复杂度为n/2</li><li>删除函数的平均时间复杂度为(n-1)/2</li></ul></div><h4 id="链式表示和实现-顺序存取法"><a href="#链式表示和实现-顺序存取法" class="headerlink" title="链式表示和实现(顺序存取法)"></a>链式表示和实现(顺序存取法)</h4><ul><li>结点在存储器中的位置是<strong>任意的</strong>，即逻辑上相邻的元素在物理上不一定相邻。</li><li>在存储元素的同时，存储其下一个元素的地址。最后一个元素的下一个元素为NULL。</li><li><strong>链表</strong>：n个结点由指针链组成一个链表。<br>每个结点由两部分组成，<strong>数据域</strong>和<strong>指针域</strong>。<ul><li><strong>单链表</strong>：每个结点只有一个指针域，用于存放后继元素的地址。</li><li><strong>双链表</strong>：每个结点有两个指针域，分别存放前趋和后继元素的地址。</li><li><strong>循环链表</strong>：首尾相接的链表，尾结点的后继元素为头结点。</li></ul></li><li><strong>头指针</strong>：指向链表中第一个结点的指针。</li><li><strong>首元结点</strong>：链表中存储第一个数据元素a<del>1</del>的结点。</li><li><strong>头结点</strong>：在首元结点之前附设的一个结点，并不统计在表长内。数据域为空或存放表长等信息，指针域指向首元结点。有以下优点：<ul><li>便于首元结点的处理。首元结点的地址也是保存在指针域中，则所有结点的操作都一样。</li><li>处理空表和非空表时操作一样。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zhongyebb/picture-gallery/main/blogs/pictures/20241003191125.png" alt="20241003191125" title="头指针、首元结点和头结点"></p><ul><li><p>优点：</p><ul><li>方便增删数据，不需要移动数据。</li><li>动态分配存储空间，不会闲置或溢出。</li></ul></li><li><p>缺点：</p><ul><li>顺序存取，查找元素需要依次扫描，查找的时间复杂度为O(n)。</li><li>存储密度小，每个结点的指针域需要额外占用存储空间。</li></ul></li><li><p>适用于长度变化较大，需要频繁进行插入或删除的场景。</p></li><li><p>链表的数据类型。以单链表为例</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span>{</span><br>  ElemType data; <span class="hljs-comment">//一般先将所有数据域封装为一个结构体ElemType</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span><br>}Lnode, *LinkList; <span class="hljs-comment">//LinkList为指向结构体Lnode的指针类型，即Lnode *p等价于LinkList p。</span><br></code></pre></td></tr></tbody></table></figure><h5 id="单链表-基本操作的代码实现"><a href="#单链表-基本操作的代码实现" class="headerlink" title="(单链表)基本操作的代码实现"></a>(单链表)基本操作的代码实现</h5><ul><li>链表的销毁要依次释放，包括头指针和头结点。</li><li>链表依然存在，即头指针和头结点保留，但链表中无元素。</li></ul><p>PS：<em>P24-34(除P32)，都在将代码实现，学过的可以直接拉到每节最后复习一下代码</em>  </p><div class="admonition note"><p class="admonition-title">note</p><ul><li>链表的查找时间复杂度为O(n)</li><li>插入和删除的时间复杂度为O(1)，但由于要从头开始查找结点，因此时间复杂度为O(n)</li></ul></div><ul><li><strong>头插法(前插法)</strong> ：每次把新元素插入链表头部，即头结点指向的位置。</li><li><strong>尾插法(后插法)</strong> ：每次把新元素插入链表尾部。</li></ul><div class="admonition attention"><p class="admonition-title">attention</p><p>个人觉得王卓老师这里讲的不太清晰。它引入了一个尾结点的概念，但代码中的这个尾结点实际上是一个临时变量r，应与头结点的概念区别开来。这里叫末元/尾元结点之类的，与首元结点概念类似的名称比较好。<strong>直观点说，头结点不是数据元素，不存数据；尾结点是数据元素，存数据</strong>。</p></div><h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><ul><li>循环链表头结点的指针域指向自身。</li><li>循环链表主要用尾指针，再由尾指针找到头指针，则查找尾结点的时间复杂度由O(n)变为O(1)。</li></ul><h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><ul><li>在单链表的每个结点里再增加一个指向其直接前趋的指针域。</li><li>首元结点的前趋为头结点，头结点的前趋为空，尾元结点的后驱为空。</li><li>空表则头结点的前趋和后继都为空。</li></ul><h5 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h5><ul><li>让头结点的前趋指向链表的尾元结点，尾元结点的后继指向头结点。空表的头结点的前趋和后继都指向自身。</li><li>具有对称性，即<code>p-&gt;prior-&gt;next=p=p-&gt;next-&gt;prior</code></li></ul><p>PS：<em>P42-P47讲代码，略</em></p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="栈的定义和特点"><a href="#栈的定义和特点" class="headerlink" title="栈的定义和特点"></a>栈的定义和特点</h5><ul><li><strong>Stack</strong>，因此一般用S表示。</li><li>操作受限的线性表，与一般线性表仅由运算规则不同——只能在表尾操作。</li><li><strong>后进先出</strong>：最后放进去的最先被拿出来，即LIFO(Last In First Out)结构。</li><li>表尾的a<del>n</del>元素，称为<strong>栈顶Top</strong>。</li><li>表头的a<del>1</del>元素，称为<strong>栈底Base</strong>。</li><li>插入元素称为<strong>入栈(PUSH)</strong> ，删除元素称为<strong>出栈(POP)</strong> 。</li><li>顺序栈和链栈存储均可，顺序栈更常见。</li></ul><h5 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h5><ul><li>上溢：栈满了仍要压入元素，视为错误。</li><li>下溢：栈空了仍要弹出元素，视为问题处理结束标志。</li></ul><h5 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h5><ul><li>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的。</li><li>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。</li><li>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。递归即采用了这种方法。有以下必备条件：<ul><li>能将一个问题转变为一个新的问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些对象的变化是有规律的。</li><li>可以通过上述转化而使问题简化。</li><li>必须有一个明确的递归出口，或称递归的边界。</li></ul></li><li>递归的调用也是后进先出，数据可以存进<strong>递归工作栈</strong>，即递归程序运行期间使用的数据存储区。</li><li>优点：结构清晰，程序易读。</li><li>缺点：每次调用要生成工作记录 ，保存状态信息，入栈；返回时要出栈，恢复状态信息，时间开销大。</li><li>要提高时间效率，可以采用以下方法：<ul><li>将尾递归、单向递归改写为循环结构for等。</li><li>自用栈来模拟系统的运行时栈。</li></ul></li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="队列的定义和特点"><a href="#队列的定义和特点" class="headerlink" title="队列的定义和特点"></a>队列的定义和特点</h5><ul><li><strong>queue</strong>，因此一般用Q表示。</li><li>操作受限的线性表，与一般线性表仅由运算规则不同——只能在表尾和表头操作。</li><li><strong>先进先出</strong>：最先进去的最先出来，队尾进队头出，即FIFO(First In First Out)。</li><li>表尾的a<del>n</del>元素，称为<strong>队尾</strong>。</li><li>表头的a<del>1</del>元素，称为<strong>队头</strong>。</li><li>插入元素称为<strong>入队</strong> ，删除元素称为<strong>出队</strong> 。</li><li>顺序队和链队存储均可，循环顺序队列更常见。</li></ul><h5 id="顺序队列的表示和实现"><a href="#顺序队列的表示和实现" class="headerlink" title="顺序队列的表示和实现"></a>顺序队列的表示和实现</h5><ul><li>非循环结构，存在<strong>假溢出</strong>，即实际有空闲的存储空间，但指针指到后面，前面的存储空间无法访问。</li><li>循环队列，解决假溢出问题。当rear指向MAXQSIZE时，将rear置0，移到一开始。<ul><li>可以加一个count来记录元素个数，用以辅助判断</li><li>或者少用一个元素空间来辅助，此时尾指针+1与头指针重合为队满，尾指针与头指针重合为队空。</li></ul></li><li>求队列长度<code>(rear-front+MAXQSIZE)%MAXQSIZE</code></li></ul><h5 id="链队的表示和实现"><a href="#链队的表示和实现" class="headerlink" title="链队的表示和实现"></a>链队的表示和实现</h5><ul><li>适用于无法估计所用长度的队列。</li></ul><h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><ul><li>内容受限的线性表，即零个或多个任意字符组成的有限序列。</li><li>用<code>s="a1a2……an"</code>表示一个串，其中<em>s</em>为<strong>串名</strong>，<em>a1a2……an</em>为<strong>串值</strong>，<em>n</em>为串长。当n=0时，称该串为<strong>空串</strong>，用Φ表示。</li><li><strong>子串</strong>：一个串中任意个连续字符组成的子序列(含空串)。包含子串的串相应地称为<strong>主串</strong>。</li><li><strong>真子串</strong>：不包含自身的所有子串。</li><li><strong>字符位置</strong>：字符在序列中的序号为该字符在串中的位置。</li><li><strong>子串位置</strong>：子串的第一个字符在主串中的位置。</li><li><strong>空格串</strong>：由一个或多个空格组成的串。</li><li><strong>串相等</strong>：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。</li><li>所有的空串都是相等的。</li><li>分顺序串和链串。</li><li>可以在一个结点中存放多个字符来提高存储密度，此时将结点称为块。</li></ul><h5 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h5><p>确定主串中所含子串(模式串)第一次出现的位置。</p><h6 id="BF算法-Brute-Force"><a href="#BF算法-Brute-Force" class="headerlink" title="BF算法(Brute-Force)"></a>BF算法(Brute-Force)</h6><ul><li>用于Index函数(S,T,pos)，其中S为主串，T为模式串。</li><li>亦称简单匹配算法，采用穷举法的思路。</li><li>用两个变量i和j来分别索引主串和模式串，将i和j所指向元素逐个比较，相同则＋1比较下一个。</li><li>当遇到不相同的字符时，i要回退置这组比较开始时的位置的下一个位置，j则回退置1。因此每次遇到不相同的元素时<code>i = i - j + 2, j = 1</code>，其中<code>j - 1</code>为这组比较已经走过的步数，<em>下标从1开始</em>，而<code>i - (j - 1)</code>则回退到这组比较开始的位置，再+1则来到下一步，再重新开始比较。</li><li>若j指向的字符为空，则匹配成功，此时<code>i - t.length</code>就是匹配字符串出现的位置。</li><li>算法复杂度O(n*m)</li></ul><h5 id="KMP算法-Knuth-Morris-Pratt"><a href="#KMP算法-Knuth-Morris-Pratt" class="headerlink" title="KMP算法(Knuth Morris Pratt)"></a>KMP算法(Knuth Morris Pratt)</h5><p>这里听了王卓老师讲的没弄懂，可以看一下b站一个up讲的<a href="https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b8bffdcb111df593c8c30e8d3791e469">连接</a></p><ul><li>首先处理模式串求出next数组。找到每个字符前面的子串中最大公共前后缀的长度，并记录在next数组中。</li><li>将主串与模式串进行比较，当发生不匹配时，根据next数组中存的值进行回溯，<code>j = next[j]</code>。</li><li>还可以对next数组进行改进，当next[j]所在位置的字符与失配位置字符相等时，此时比较仍然时是不同的，因此可以直接跳转至next[next[j]]，即<code>nextval[j] = next[next[j]]</code></li><li>相比于BF算法提高了时间效率，时间复杂度为O(n+m)。</li></ul><p>求next数组的代码有点难懂，在上面提到的那个视频中最后讲解的就是。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetNext</span><span class="hljs-params">(<span class="hljs-type">char</span> ch[], <span class="hljs-type">int</span> length, <span class="hljs-type">int</span> next[])</span>{<br>  next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//next从1开始存</span><br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; <span class="hljs-comment">//注意这里i代表模式主串中下标位置，j用作索引</span><br>  <span class="hljs-keyword">while</span>(i &lt;= length){<br>    <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || ch[i] == ch[j]) { <br>    <span class="hljs-comment">//我们已经知道前一个元素的最长匹配后缀的长度了，此时后一个字符与前一个字符的最长前缀的后一个字符相等，</span><br>    <span class="hljs-comment">//那么对于这个字符的最长匹配后缀则在前一个字符最长匹配长度的基础上+1即可。</span><br>      ++i; ++j;<br>      next[i] = j;<br>    }<br>    <span class="hljs-keyword">else</span> j = next[j];<span class="hljs-comment">//若不等则跳转至前一个匹配子串处再比较</span><br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><div class="admonition note"><p class="admonition-title">note</p><p>next数组从下标1开始存值，即第一个数的下标为1。</p></div><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li>线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。</li><li>数组的<strong>结构固定</strong>，即定义后维数和维界不再改变。</li><li>数组可以是多维的，但存储数据元素的内存单元地址是一维的。</li><li>一维数组，每个元素的地址为<code>a+i*L</code>，其中a为其实地址，i为元素下标，L为每个元素占用字节数。</li><li>二位数组有两种存储方式：<ul><li>以行序为主序，每一行存完再存下一行，如C、JAVA等</li><li>以列序为主序，每一列存完再存下一列。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习历程</title>
    <link href="/2024/09/27/%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <url>/2024/09/27/%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h3><ul><li>timeline：9.27</li><li>学习资料<ul><li><a href="www.markdowntutorial.com">网站</a> (可以边学边做学得很快，但是只有基础语法)</li><li><a href="www.markdown.cn/docs/tutorial-basics/basic-syntax">官网手册</a>(有代码、列表等拓展语法)</li></ul></li></ul><h3 id="GitHub个人主页搭建"><a href="#GitHub个人主页搭建" class="headerlink" title="GitHub个人主页搭建"></a>GitHub个人主页搭建</h3><ul><li>timeline: 9.27</li><li>学习资料<ul><li><a href="https://www.bilibili.com/read/cv32931591/?jump_opus=1">Hexo+guihub=个人网站</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%BC%BA%E5%88%B6%E5%85%A8%E5%B1%80-https">Hexo fluid官方用户手册</a>（墙裂安利，可以找到很多有用的功能）</li><li><a href="https://zhongyebb.github.io/2024/05/02/hello-world/">Hexo常用指令</a></li><li><a href="https://cloud.tencent.com/developer/article/1952241">Hexo插件</a></li><li><a href="https://cyberzone.cloud/2023/11/11/Fluid%E4%BD%BF%E7%94%A8Waline%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/#2-2-Vercel-%E9%83%A8%E7%BD%B2-%E6%9C%8D%E5%8A%A1%E7%AB%AF">增加评论功能waline</a>(存在一些问题)</li><li><a href="https://blog.csdn.net/qq_44314954/article/details/122951033">github图床搭建</a></li></ul></li><li>问题 <span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><ul><li><a href="https://zhongyebb.github.io/2024/09/28/hexo-admonition%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/">hexo admonition插件安装问题</a>（耗时两个小时解决）</li><li>[增加访问量功能及出现的问题]</li></ul></li></ul><h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><ul><li>timeline：</li></ul><table><thead><tr><th>时间</th><th>内容</th><th>备注</th></tr></thead><tbody><tr><td>9.28-10.02</td><td>绪论</td><td>很简单但是这段时间摸鱼了<span class="github-emoji"><span>😠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f620.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr><tr><td>10.02-10.4</td><td>线性表</td><td>基本上都是学过的，库库过，拉到最后直接看代码</td></tr><tr><td>10.04</td><td>刷题-二分法</td><td>用到的是<a href="https://www.programmercarl.com/">代码随想录</a></td></tr><tr><td>10.06</td><td>刷题-双指针+滑动窗口</td><td>太痛苦了</td></tr></tbody></table><ul><li>学习资料<ul><li><a href="https://www.bilibili.com/video/BV1nJ411V7bd/">王卓网课</a></li></ul></li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/02/hello-world/"/>
    <url>/2024/05/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
